목표
빅오표기법의 필요성 알기
시간복잡성과 공간복잡성 정의
빅오표기법을 통해 알고리즘 평가

빅오표기법의 필요성
여러가지 코드를 서로 비교하고 성능을 평가하는 방법
코드를 분류하거나 비교할수 있는 시스템이 필요
빅오표기법의 목적이 바로 이것
제대로 동작하는것이 가장 좋은 해결법일수 있으나 면접이나 코드챌린지, 수천개의 데이터를 처리할때는 빠른 알고리즘이 필요하다.
실제 좋은 정답이 존재한다는 의미
빅오를 이해하면 문제를 디버그하기 쉬워진다.

예제
1에서부터 특정한 N값과 사이에 잇는 모든 숫자들을 더하는 펑션을 쓰고 싶다고 생각해보세요
만약 3을 입력하면 1+2+3=6이 나옵니다.

// 1부터 n까지 사이의 수를 모두 더하는 함수
function addUIpTo(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
console.log(addUIpTo(6)); //21
console.log(addUIpTo(100)); //5050

// 위 함수보다 더 빠른 함수
function addUIpTo2(n) {
  return (n * (n + 1)) / 2;
}
console.log(addUIpTo2(6)); //21
console.log(addUIpTo2(100)); //5050

더 나은 답은 무엇인가?
만약 1~10억을 더해야한다면 아래 함수가 훨씬 빠를것이다.


test방법 

let t1 = performance.now();
addUIpTo(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds`); //0.8936050000041723 seconds

let t3 = performance.now();
addUIpTo2(1000000000);
let t4 = performance.now();
console.log(`Time Elapsed: ${(t4 - t3) / 1000} seconds`); //0.000013099998235702514 seconds

두번째 함수가 훨씬 빠름

하지만 이렇게 매번 시간을 재보는것도 정답은 아님
왜냐?
기기 사양마다, 데이터의 크기마다 시간자체는 다를 수 있기 때문!!
정말 안좋은 컴퓨터로 두번째 함수를 사용하고 슈퍼컴퓨터로 첫번째 함수를 사용하면 어쩌면 첫번째가 더 빠를 수 있기 때문...
또한 코드 자체가 시간이 한시간 넘게 걸리는 코드를 비교해야한다면 그 시간만큼 기다려야하는 문제가 있음..

그래서 정확한 시간을 재는것보다 연산의 수를 세는 방법이 도입됨
정확한 숫자를 세는게 아닌 그 추세를 봅니다.



